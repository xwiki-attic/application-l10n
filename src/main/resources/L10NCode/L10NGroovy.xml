<?xml version="1.0" encoding="UTF-8"?>

<xwikidoc version="1.3" reference="L10NCode.L10NGroovy" locale="">
  <web>L10NCode</web>
  <name>L10NGroovy</name>
  <language/>
  <defaultLanguage/>
  <translation>0</translation>
  <creator>xwiki:XWiki.Admin</creator>
  <creationDate>1225046934000</creationDate>
  <author>xwiki:XWiki.Admin</author>
  <contentAuthor>xwiki:XWiki.Admin</contentAuthor>
  <date>1493800962000</date>
  <contentUpdateDate>1493800962000</contentUpdateDate>
  <version>1.1</version>
  <title>L10NGroovy</title>
  <comment/>
  <minorEdit>false</minorEdit>
  <syntaxId>xwiki/2.1</syntaxId>
  <hidden>true</hidden>
  <content>/*
 #* L10N Application Groovy Code
 *
 * Allows to manage translations page, including import/export.
 * @type groovy
 * @programming
 *
 *#
 #*
 */

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.Reader;
import java.io.StringReader;
import java.io.StringWriter;
import java.io.UnsupportedEncodingException;
import java.io.Writer;
import java.net.URLEncoder;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.TreeSet;
import java.util.regex.Pattern;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

import org.apache.commons.httpclient.HttpClient;
import org.apache.commons.httpclient.HttpStatus;
import org.apache.commons.httpclient.methods.GetMethod;
import org.apache.commons.lang.ObjectUtils;
import org.apache.commons.lang.StringUtils;
import org.apache.ecs.storage.Array;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.xwiki.model.EntityType;
import org.xwiki.model.reference.DocumentReference;
import org.xwiki.model.reference.EntityReference;
import org.xwiki.query.Query;
import org.xwiki.query.QueryException;
import org.xwiki.query.QueryManager;
import org.xwiki.rendering.syntax.Syntax;

import com.xpn.xwiki.XWikiContext;
import com.xpn.xwiki.XWikiException;
import com.xpn.xwiki.api.Context;
import com.xpn.xwiki.api.Document;
import com.xpn.xwiki.api.Property;
import com.xpn.xwiki.api.XWiki;
import com.xpn.xwiki.doc.XWikiDocument;
import com.xpn.xwiki.web.XWikiServletRequest;

import groovy.json.JsonSlurper;

public class L10NApp
{
    protected static final Logger LOGGER = LoggerFactory.getLogger(L10NApp.class);

    /**
     * Same as java.util.Properties but with the following changes:
     * &lt;ul&gt;
     * &lt;li&gt;Parse comments to find informations related to the key&lt;/li&gt;
     * &lt;li&gt;The order of the file is kept&lt;/li&gt;
     * &lt;/ul&gt;
     */
    public static class TranslationBundleReader extends LinkedHashMap&lt;String, TranslationBundleReader.Translation&gt;
    {
        public static class Translation
        {
            private String key;

            private String value;

            private String comment;

            private boolean deprecated;

            private String newKey;

            public Translation(String key, String value, String comment, boolean deprecated, String newKey)
            {
                this.key = key;
                this.value = value;

                this.comment = comment;

                this.deprecated = deprecated;
                this.newKey = newKey;
            }

            public String getKey()
            {
                return this.key;
            }

            public String getValue()
            {
                return this.value;
            }

            public String getComment()
            {
                return this.comment;
            }

            public boolean isDeprecated()
            {
                return this.deprecated;
            }

            public String getNewKey()
            {
                return this.newKey;
            }
        }

        public synchronized void load(Reader reader) throws IOException
        {
            load0(new LineReader(reader));
        }

        /**
         * Reads a property list (key and element pairs) from the input byte stream. The input stream is in a simple
         * line-oriented format as specified in {@link #load(java.io.Reader) load(Reader)} and is assumed to use the ISO
         * 8859-1 character encoding; that is each byte is one Latin1 character. Characters not in Latin1, and certain
         * special characters, are represented in keys and elements using &lt;a
         * href="http://java.sun.com/docs/books/jls/third_edition/html/lexical.html#3.3"&gt;Unicode escapes&lt;/a&gt;.
         * &lt;p&gt;
         * The specified stream remains open after this method returns.
         * 
         * @param inStream the input stream.
         * @exception IOException if an error occurred when reading from the input stream.
         * @throws IllegalArgumentException if the input stream contains a malformed Unicode escape sequence.
         * @since 1.2
         */
        public synchronized void load(InputStream inStream) throws IOException
        {
            load0(new LineReader(inStream));
        }

        private void load0(LineReader lr) throws IOException
        {
            char[] convtBuf = new char[1024];
            int limit;
            int keyLen;
            int valueStart;
            char c;
            boolean hasSep;
            boolean precedingBackslash;

            // Added to the following translation
            StringBuilder comment = null;
            String newKey = null;
            boolean deprecated = false;
            boolean nextdeprecated = false;

            while ((limit = lr.readLine()) &gt;= 0) {
                char firstChar = lr.lineBuf[0];

                if (firstChar == '#' || firstChar == '!') {
                    if (limit &gt; 3 &amp;&amp; lr.lineBuf[1] == firstChar &amp;&amp; lr.lineBuf[2] == firstChar) {
                        if (comment != null) {
                            comment.setLength(0);
                        }
                    } else {
                        if (comment == null) {
                            comment = new StringBuilder();
                        }

                        if (comment.length() &gt; 0) {
                            comment.append('\n');
                        }

                        comment.append(lr.lineBuf, 1, limit - 1);

                        if (startWith(lr.lineBuf, "#@deprecated")) {
                            if (startWith(lr.lineBuf, "#@deprecatedstart")) {
                                deprecated = true;
                            } else if (startWith(lr.lineBuf, "#@deprecatedend")) {
                                deprecated = false;
                            } else {
                                // extract new key
                                newKey =
                                    extractKey(lr.lineBuf, "#@deprecated".length(), limit - "#@deprecated".length(),
                                        convtBuf);
                                nextdeprecated = true;
                            }
                        }
                    }
                } else {
                    c = 0;
                    keyLen = 0;
                    valueStart = limit;
                    hasSep = false;

                    // System.out.println("line=&lt;" + new String(lineBuf, 0, limit) + "&gt;");
                    precedingBackslash = false;
                    while (keyLen &lt; limit) {
                        c = lr.lineBuf[keyLen];
                        // need check if escaped.
                        if ((c == '=' || c == ':') &amp;&amp; !precedingBackslash) {
                            valueStart = keyLen + 1;
                            hasSep = true;
                            break;
                        } else if ((c == ' ' || c == '\t' || c == '\f') &amp;&amp; !precedingBackslash) {
                            valueStart = keyLen + 1;
                            break;
                        }
                        if (c == '\\') {
                            precedingBackslash = !precedingBackslash;
                        } else {
                            precedingBackslash = false;
                        }
                        keyLen++;
                    }
                    while (valueStart &lt; limit) {
                        c = lr.lineBuf[valueStart];
                        if (c != ' ' &amp;&amp; c != '\t' &amp;&amp; c != '\f') {
                            if (!hasSep &amp;&amp; (c == '=' || c == ':')) {
                                hasSep = true;
                            } else {
                                break;
                            }
                        }
                        valueStart++;
                    }
                    String key = loadConvert(lr.lineBuf, 0, keyLen, convtBuf);

                    if (isValidKey(key)) {
                        String value = loadConvert(lr.lineBuf, valueStart, limit - valueStart, convtBuf);

                        Translation translation =
                            new Translation(key, value, comment != null ? comment.toString().trim() : null, deprecated
                                | nextdeprecated, newKey);

                        put(key, translation);

                        // Cleanup
                        if (newKey != null) {
                            newKey = null;
                        }
                        if (comment != null) {
                            comment = null;
                        }
                        nextdeprecated = false;
                    }
                }
            }
        }

        private boolean startWith(char[] buffer, CharSequence str)
        {
            for (int i = 0; i &lt; str.length(); ++i) {
                if (buffer.length &lt;= i || buffer[i] != str.charAt(i)) {
                    return false;
                }
            }

            return true;
        }

        private String extractKey(char[] buffer, int start, int len, char[] convtBuf)
        {
            String rawKey = loadConvert(buffer, start, len, convtBuf);

            rawKey = rawKey.trim();

            if (rawKey.isEmpty()) {
                return null;
            }

            return isValidKey(rawKey) ? rawKey : null;
        }

        private boolean isValidKey(String key)
        {
            for (int i = 0; i &lt; key.length(); ++i) {
                if (!isValidKeyChar(key.charAt(i))) {
                    return false;
                }
            }

            return true;
        }

        private boolean isValidKeyChar(char c)
        {
            switch (c) {
                case ' ':
                case '\t':
                case '\f':
                case '=':
                case ':':
                case '{':
                case '}':
                case '[':
                case ']':
                    return false;

                default:
                    break;
            }

            return true;
        }

        /*
         * Read in a "logical line" from an InputStream/Reader, skip all comment and blank lines and filter out those
         * leading whitespace characters ( , and ) from the beginning of a "natural line". Method returns the char
         * length of the "logical line" and stores the line in "lineBuf".
         */
        class LineReader
        {
            public LineReader(InputStream inStream)
            {
                this.inStream = inStream;
                inByteBuf = new byte[8192];
            }

            public LineReader(Reader reader)
            {
                this.reader = reader;
                inCharBuf = new char[8192];
            }

            byte[] inByteBuf;

            char[] inCharBuf;

            char[] lineBuf = new char[1024];

            int inLimit = 0;

            int inOff = 0;

            InputStream inStream;

            Reader reader;

            int readLine() throws IOException
            {
                int len = 0;
                char c = 0;

                boolean skipWhiteSpace = true;
                boolean isNewLine = true;
                boolean appendedLineBegin = false;
                boolean precedingBackslash = false;
                boolean skipLF = false;

                while (true) {
                    if (inOff &gt;= inLimit) {
                        inLimit = (inStream == null) ? reader.read(inCharBuf) : inStream.read(inByteBuf);
                        inOff = 0;
                        if (inLimit &lt;= 0) {
                            if (len == 0) {
                                return -1;
                            }
                            return len;
                        }
                    }
                    if (inStream != null) {
                        // The line below is equivalent to calling a
                        // ISO8859-1 decoder.
                        c = (char) (0xff &amp; inByteBuf[inOff++]);
                    } else {
                        c = inCharBuf[inOff++];
                    }
                    if (skipLF) {
                        skipLF = false;
                        if (c == '\n') {
                            continue;
                        }
                    }
                    if (skipWhiteSpace) {
                        if (c == ' ' || c == '\t' || c == '\f') {
                            continue;
                        }
                        if (!appendedLineBegin &amp;&amp; (c == '\r' || c == '\n')) {
                            continue;
                        }
                        skipWhiteSpace = false;
                        appendedLineBegin = false;
                    }
                    if (isNewLine) {
                        isNewLine = false;
                    }

                    if (c != '\n' &amp;&amp; c != '\r') {
                        lineBuf[len++] = c;
                        if (len == lineBuf.length) {
                            int newLength = lineBuf.length * 2;
                            if (newLength &lt; 0) {
                                newLength = Integer.MAX_VALUE;
                            }
                            char[] buf = new char[newLength];
                            System.arraycopy(lineBuf, 0, buf, 0, lineBuf.length);
                            lineBuf = buf;
                        }
                        // flip the preceding backslash flag
                        if (c == '\\') {
                            precedingBackslash = !precedingBackslash;
                        } else {
                            precedingBackslash = false;
                        }
                    } else {
                        // reached EOL
                        if (len == 0) {
                            isNewLine = true;
                            skipWhiteSpace = true;
                            len = 0;
                            continue;
                        }
                        if (inOff &gt;= inLimit) {
                            inLimit = (inStream == null) ? reader.read(inCharBuf) : inStream.read(inByteBuf);
                            inOff = 0;
                            if (inLimit &lt;= 0) {
                                return len;
                            }
                        }
                        if (precedingBackslash) {
                            len -= 1;
                            // skip the leading whitespace characters in following line
                            skipWhiteSpace = true;
                            appendedLineBegin = true;
                            precedingBackslash = false;
                            if (c == '\r') {
                                skipLF = true;
                            }
                        } else {
                            return len;
                        }
                    }
                }
            }
        }

        /*
         * Converts encoded &amp;#92;uxxxx to unicode chars and changes special saved chars to their original forms
         */
        private String loadConvert(char[] input, int off, int len, char[] convtBuf)
        {
            if (convtBuf.length &lt; len) {
                int newLen = len * 2;
                if (newLen &lt; 0) {
                    newLen = Integer.MAX_VALUE;
                }
                convtBuf = new char[newLen];
            }
            char aChar;
            char[] out = convtBuf;
            int outLen = 0;
            int end = off + len;

            while (off &lt; end) {
                aChar = input[off++];
                if (aChar == '\\') {
                    aChar = input[off++];
                    if (aChar == 'u') {
                        // Read the xxxx
                        int value = 0;
                        for (int i = 0; i &lt; 4; i++) {
                            aChar = input[off++];
                            switch (aChar) {
                                case '0':
                                case '1':
                                case '2':
                                case '3':
                                case '4':
                                case '5':
                                case '6':
                                case '7':
                                case '8':
                                case '9':
                                    value = (value &lt;&lt; 4) + aChar - (char) '0';
                                    break;
                                case 'a':
                                case 'b':
                                case 'c':
                                case 'd':
                                case 'e':
                                case 'f':
                                    value = (value &lt;&lt; 4) + 10 + aChar - (char) 'a';
                                    break;
                                case 'A':
                                case 'B':
                                case 'C':
                                case 'D':
                                case 'E':
                                case 'F':
                                    value = (value &lt;&lt; 4) + 10 + aChar - (char) 'A';
                                    break;
                                default:
                                    throw new IllegalArgumentException("Malformed \\uxxxx encoding.");
                            }
                        }
                        out[outLen++] = (char) value;
                    } else {
                        if (aChar == 't')
                            aChar = '\t';
                        else if (aChar == 'r')
                            aChar = '\r';
                        else if (aChar == 'n')
                            aChar = '\n';
                        else if (aChar == 'f')
                            aChar = '\f';
                        out[outLen++] = aChar;
                    }
                } else {
                    out[outLen++] = aChar;
                }
            }

            return new String(out, 0, outLen);
        }
    }

    public static final String TRANSLATOR_NAME = "XWikiTranslator";

    public static final String TRANSLATOR_FULL_NAME = "XWiki.${TRANSLATOR_NAME}";

    private static final String CACHEKEY_OPEN = "[";

    private static final String CACHEKEY_CLOSE = "]";

    private static final String CACHEKEY_OPENP = Pattern.quote(CACHEKEY_OPEN);

    private static final String CACHEKEY_CLOSEP = Pattern.quote(CACHEKEY_CLOSE);

    private static final String T_PROP_LANGUAGE = "language";

    private static final String T_PROP_NAME = "name";

    private static final String T_PROP_KEY = "key";

    private static final String T_PROP_STATUS = "status";

    private static final String T_PROP_ORIGINALTEXT = "originaltext";

    private static final String T_PROP_TRANSLATEDTEXT = "translatedtext";

    private static final String T_PROP_COMMENT = "comment";

    private static final String T_PROP_DEPRECATED = "deprecated";

    private static final String T_PROP_NEWKEY = "deprecatedNewKey";

    private static final Map&lt;String, Object&gt; countCache = new HashMap&lt;String, Object&gt;();

    private static final Map&lt;String, Object&gt; countByUserCache = new HashMap&lt;String, Object&gt;();

    private static final Map&lt;String, Object&gt; countByLanguageCache = new HashMap&lt;String, Object&gt;();

    private static final Map&lt;String, Object&gt; countEmptyCache = new HashMap&lt;String, Object&gt;();

    private static final Map&lt;String, Object&gt; countToReviewCache = new HashMap&lt;String, Object&gt;();

    private static final Map&lt;String, Object&gt; countOutdatedCache = new HashMap&lt;String, Object&gt;();

    private static final Map&lt;String, Object&gt; countNonexistentCache = new HashMap&lt;String, Object&gt;();

    private static final Map&lt;String, Object&gt; lastTranslationsCache = new HashMap&lt;String, Object&gt;();

    private Context context;

    private XWiki xwiki;

    private com.xpn.xwiki.XWiki privateXWiki;

    private XWikiContext privateContext;

    private String lastsql;

    private QueryManager queryManager;

    private QueryManager getQueryManager()
    {
        if (queryManager == null) {
            queryManager = com.xpn.xwiki.web.Utils.getComponent(QueryManager.class);
        }

        return queryManager;
    }

    public void clearCache()
    {
        countCache.clear();
        countByUserCache.clear();
        countEmptyCache.clear();
        countToReviewCache.clear();
        countOutdatedCache.clear();
        countNonexistentCache.clear();
        lastTranslationsCache.clear();
    }

    public void clearMapCache(Map&lt;String, ?&gt; map, String app, String name)
    {
        clearMapCache(map, "${app}_${name}");
    }

    public void clearMapCache(Map&lt;String, ?&gt; map, String startWith)
    {
        List&lt;String&gt; list = new ArrayList&lt;String&gt;();
        for (String key : map.keySet()) {
            if (key.startsWith(startWith)) {
                list.add(key);
            }
        }

        for (String key : list) {
            map.remove(key);
        }
    }

    public void clearCache(String app, String file)
    {
        removeFromCache(countCache, app, file, null, null);
        removeFromCache(countByUserCache, app, file, null, null);
        removeFromCache(countEmptyCache, app, file, null, null);
        removeFromCache(countToReviewCache, app, file, null, null);
        removeFromCache(countOutdatedCache, app, file, null, null);
        removeFromCache(countNonexistentCache, app, file, null, null);
        removeFromCache(lastTranslationsCache, app, file, null, null);
    }

    public void clearCache(String app, String file, String language)
    {
        removeFromCache(countCache, app, file, language, null);
        removeFromCache(countByUserCache, app, file, language, null);
        removeFromCache(countEmptyCache, app, file, language, null);
        removeFromCache(countToReviewCache, app, file, language, null);
        removeFromCache(countOutdatedCache, app, file, language, null);
        removeFromCache(countNonexistentCache, app, file, language, null);
        removeFromCache(lastTranslationsCache, app, file, language, null);
    }

    public void addToCache(Map&lt;String, Object&gt; cache, Object value, String app, String file, String language,
        String author, Integer nb, Integer start, boolean withTranslator)
    {
        addToCache(cache, value, app, file, language, author, nb, start, withTranslator, null);
    }

    public void addToCache(Map&lt;String, Object&gt; cache, Object value, String app, String file, String language,
        String author, Integer nb, Integer start, boolean withTranslator, Object keySuffix)
    {
        cache.put(createKey(app, file, language, author, nb, start, withTranslator, keySuffix), value);
    }

    public Object getFromCache(Map&lt;String, ?&gt; cache, String app, String file, String language, String author,
        Integer nb, Integer start, boolean withTranslator)
    {
        return getFromCache(cache, app, file, language, author, nb, start, withTranslator, null);
    }

    public Object getFromCache(Map&lt;String, ?&gt; cache, String app, String file, String language, String author,
        Integer nb, Integer start, boolean withTranslator, Object keySuffix)
    {
        return cache.get(createKey(app, file, language, author, nb, start, withTranslator, keySuffix));
    }

    public String createKey(String app, String file, String language, String author, Integer nb, Integer start,
        boolean withTranslator)
    {
        return createKey(app, file, language, author, nb, start, withTranslator, null);
    }

    public String createKey(String app, String file, String language, String author, Integer nb, Integer start,
        boolean withTranslator, Object keySuffix)
    {
        StringBuffer key = new StringBuffer();

        key.append(CACHEKEY_OPEN);
        if (app != null) {
            key.append(app);
        }
        key.append(CACHEKEY_CLOSE);

        key.append(CACHEKEY_OPEN);
        if (file != null) {
            key.append(file);
        }
        key.append(CACHEKEY_CLOSE);

        key.append(CACHEKEY_OPEN);
        if (language != null) {
            key.append(language);
        }
        key.append(CACHEKEY_CLOSE);

        key.append(CACHEKEY_OPEN);
        if (author != null) {
            key.append(author);
        }
        key.append(CACHEKEY_CLOSE);

        key.append(CACHEKEY_OPEN);
        if (nb != null) {
            key.append(nb);
        }
        key.append(CACHEKEY_CLOSE);

        key.append(CACHEKEY_OPEN);
        if (start != null) {
            key.append(start);
        }
        key.append(CACHEKEY_CLOSE);

        key.append(CACHEKEY_OPEN);
        key.append(withTranslator);
        key.append(CACHEKEY_CLOSE);

        if (keySuffix != null) {
            key.append('_');
            key.append(keySuffix);
        }

        return key.toString();
    }

    public void removeFromCache(Map&lt;String, ?&gt; cache, Pattern pattern)
    {
        List&lt;String&gt; list = new ArrayList&lt;String&gt;();
        for (String key : cache.keySet()) {
            if (pattern.matcher(key).matches()) {
                list.add(key);
            }
        }

        for (String key : list) {
            cache.remove(key);
        }
    }

    public void removeFromCache(Map&lt;String, ?&gt; cache, String app, String file, String language, String author)
    {
        StringBuffer pattern = new StringBuffer();

        // app
        pattern.append(CACHEKEY_OPENP);
        if (app != null) {
            pattern.append("(" + Pattern.quote(app) + ")?");
        } else {
            pattern.append(".*");
        }
        pattern.append(CACHEKEY_CLOSEP);

        // file
        pattern.append(CACHEKEY_OPENP);
        if (file != null) {
            pattern.append("(" + Pattern.quote(file) + ")?");
        } else {
            pattern.append(".*");
        }
        pattern.append(CACHEKEY_CLOSEP);

        // language
        pattern.append(CACHEKEY_OPENP);
        if (language != null) {
            pattern.append("(" + Pattern.quote(language) + ")?");
        } else {
            pattern.append(".*");
        }
        pattern.append(CACHEKEY_CLOSEP);

        // author
        pattern.append(CACHEKEY_OPENP);
        if (author != null) {
            pattern.append("(" + Pattern.quote(author) + ")?");
        } else {
            pattern.append(".*");
        }
        pattern.append(CACHEKEY_CLOSEP);

        // nb
        pattern.append(CACHEKEY_OPENP);
        pattern.append(".*");
        pattern.append(CACHEKEY_CLOSEP);

        // start
        pattern.append(CACHEKEY_OPENP);
        pattern.append(".*");
        pattern.append(CACHEKEY_CLOSEP);

        // withTranslator
        pattern.append(CACHEKEY_OPENP);
        pattern.append(".*");
        pattern.append(CACHEKEY_CLOSEP);

        removeFromCache(cache, Pattern.compile(pattern.toString()));
    }

    public Map&lt;String, Object&gt; getCountCache()
    {
        return countCache;
    }

    public void setContext(Context context, XWiki xwiki) throws SecurityException, NoSuchFieldException,
        IllegalArgumentException, IllegalAccessException
    {
        this.context = context;
        this.xwiki = xwiki;

        java.lang.reflect.Field f = com.xpn.xwiki.api.Api.class.getDeclaredField("context");
        f.setAccessible(true);

        this.privateContext = (XWikiContext) f.get(context);
        this.privateXWiki = privateContext.getWiki();
    }

    public String getLastSQL()
    {
        return lastsql;
    }

    public String getPageName(String name, String key, String language)
    {
        return xwiki.clearName(name) + "_" + key.hashCode() + "_" + StringUtils.replace(key, ".", "-") + "_${language}";
    }

    public String getDefaultLanguage() throws XWikiException
    {
        Document l10ndoc = xwiki.getDocument("L10N.WebHome");
        String lang = (String) l10ndoc.getValue("defaultlanguage");
        if (StringUtils.isEmpty(lang)) {
            return "en";
        } else {
            return lang;
        }
    }

    public String[] getLanguages() throws XWikiException
    {
        Document l10ndoc = xwiki.getDocument("L10N.WebHome");
        String lang = (String) l10ndoc.getValue("defaultlanguages");
        if (StringUtils.isEmpty(lang)) {
            return "fr,de,es,it".split(",");
        } else {
            return lang.split(",");
        }
    }

    /* application management functions */

    public List&lt;String&gt; getApplications() throws XWikiException
    {
        String sql =
            ", BaseObject as obj where doc.fullName=obj.name and obj.className='L10NCode.L10NApplicationClass'";

        return xwiki.searchDocuments(sql);
    }

    public List&lt;String&gt; getApplicationsNames() throws XWikiException
    {
        String sql =
            "select distinct doc.space from XWikiDocument doc, BaseObject as obj where doc.fullName=obj.name and obj.className='L10NCode.L10NApplicationClass'";

        return this.privateXWiki.search(sql, this.privateContext);
    }

    public boolean addApplication(XWikiServletRequest request) throws XWikiException
    {
        String spaceName = request.get("space");
        Document appdoc = xwiki.getDocument("${spaceName}.WebHome");
        if (!appdoc.isNew())
            return false;
        else {
            appdoc.addObjectFromRequest("L10NCode.L10NApplicationClass");
            appdoc.setContent("#includeForm(\"L10NCode.L10NApplicationClassSheet\")");
            appdoc.save();

            return true;
        }
    }

    public Collection&lt;String&gt; getAllLanguages() throws XWikiException
    {
        Collection&lt;String&gt; languages = new TreeSet&lt;String&gt;();

        for (String appName : getApplicationsNames()) {
            try {
                for (String language : getApplicationLanguages(appName)) {
                    languages.add(language);
                }
            } catch (XWikiException e) {
                e.printStackTrace();
            }
        }

        return languages;
    }

    public String[] getApplicationLanguages(String app) throws XWikiException
    {
        String[] languages;

        Document appdoc = xwiki.getDocument("${app}.WebHome");
        String lang = (String) appdoc.getValue("languages");

        if (StringUtils.isEmpty(lang)) {
            languages = getLanguages();
        } else {
            languages = lang.split(",");
        }

        Arrays.sort(languages);

        return languages;
    }

    public String getApplicationDefaultLanguage(String app) throws XWikiException
    {
        Document appdoc = xwiki.getDocument("${app}.WebHome");

        return getApplicationDefaultLanguage(appdoc);
    }

    public String getApplicationDefaultLanguage(Document appdoc) throws XWikiException
    {
        String lang = (String) appdoc.getValue("defaultlanguage");
        if (StringUtils.isEmpty(lang)) {
            return getDefaultLanguage();
        } else {
            return lang;
        }
    }

    /* translation files management functions */

    public List&lt;Map&lt;String, Object&gt;&gt; getTranslationsFiles(String app) throws XWikiException
    {
        List&lt;Map&lt;String, Object&gt;&gt; list = new ArrayList&lt;Map&lt;String, Object&gt;&gt;();

        String sql =
            ", BaseObject as obj where doc.web='${app}' and doc.fullName=obj.name and obj.className='L10NCode.TranslationFileClass'";

        for (String item : xwiki.searchDocuments(sql)) {
            Document transfiledoc = xwiki.getDocument(item);
            transfiledoc.use("L10NCode.TranslationFileClass");
            Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();
            map.put("page", transfiledoc.getFullName());
            map.put("name", transfiledoc.getValue(T_PROP_NAME));
            map.put("type", transfiledoc.getValue("type"));
            map.put("url", transfiledoc.getValue("url"));
            map.put("state", transfiledoc.getValue("state"));
            list.add(map);
        }

        return list;
    }

    public Document getTranslationFile(String page) throws XWikiException
    {
        return xwiki.getDocument(page);
    }

    public String findLanguageURL(Document doc, String language) throws XWikiException
    {
        String url = (String) doc.getValue("url");
        String dlang = getApplicationDefaultLanguage(doc.getSpace());
        String type = (String) doc.getValue("type");
        if (type == "exportedwikipage" || type == "exportedwikitrans") {
            if (url.indexOf("_${dlang}.properties") != -1) {
                return url.replaceAll("\\.${dlang}.xml", ".${language}.xml");
            } else {
                return url.replaceAll("\\.xml", ".${language}.xml");
            }
        } else if (type == "resource") {
            // type is ApplicationResources
            if (url.indexOf("_${dlang}.properties") != -1) {
                return url.replaceAll("_${dlang}\\.properties", "_${language}.properties");
            } else {
                return url.replaceAll("\\.properties", "_${language}.properties");
            }
        } else {
            return url;
        }
    }

    public Document addTranslationFile(String app, XWikiServletRequest request) throws XWikiException
    {
        if (app == null || request == null) {
            return null;
        }

        String name = request.get("L10NCode.TranslationFileClass_0_name");
        String pagename = xwiki.getUniquePageName(app, name);
        Document transfiledoc = xwiki.getDocument("${app}.${pagename}");
        transfiledoc.addObjectFromRequest("L10NCode.TranslationFileClass");
        transfiledoc.setContent("{{include document=\"L10NCode.TranslationFileClassSheet20\"}}");
        transfiledoc.setSyntaxId("xwiki/2.0");
        transfiledoc.save();

        return transfiledoc;
    }

    public void removeTranslationFile(String page) throws XWikiException
    {
        Document transfiledoc = xwiki.getDocument(page);

        com.xpn.xwiki.api.Object obj = transfiledoc.getObject("L10NCode.TranslationClass");

        String app = transfiledoc.getSpace();
        String name = (String) obj.getProperty(T_PROP_NAME).getValue();
        String lang = (String) obj.getProperty(T_PROP_LANGUAGE).getValue();

        transfiledoc.delete();

        clearCache(app, name, lang);
    }

    /* import functions */

    public int importTranslations(String app, String name, String language, String urlorpage) throws Exception
    {
        Document transfiledoc = xwiki.getDocument(name);
        String stype = (String) transfiledoc.getValue("type");
        if (stype.equals("resource")) {
            return importApplicationResourcesFromURL(app, name, language, urlorpage);
        } else if (stype.equals("exportedwikipage")) {
            return importWikiPageFromURL(app, name, language, urlorpage);
        } else if (stype.equals("exportedwikitrans")) {
            return importTranslationWikiPageFromURL(app, name, language, urlorpage);
        } else if (stype.equals("wikipage")) {
            return importWikiPageFromWiki(app, name, language, urlorpage);
        } else if (stype.equals("wikitrans")) {
            return importTranslationWikiPageFromWiki(app, name, language, urlorpage);
        } else {
            return -1;
        }
    }

    public TranslationBundleReader getTranslationsFromURL(String surl) throws Exception
    {
        HttpClient client =
            com.xpn.xwiki.XWiki.getHttpClient(privateXWiki.getHttpTimeout(privateContext),
                privateXWiki.getHttpUserAgent(privateContext));

        GetMethod get = new GetMethod(surl);

        try {
            client.executeMethod(get);

            int code = get.getStatusCode();
            if (code != HttpStatus.SC_OK) {
                throw new Exception("Failed to get content for URL [${surl}]: code [${code}]");
            }

            // read the properties from url
            TranslationBundleReader translationReader = new TranslationBundleReader();
            translationReader.load(get.getResponseBodyAsStream());

            return translationReader;
        } finally {
            get.releaseConnection();
        }
    }

    public Properties getPropertiesFromURL(String surl) throws Exception
    {
        HttpClient client =
            com.xpn.xwiki.XWiki.getHttpClient(privateXWiki.getHttpTimeout(privateContext),
                privateXWiki.getHttpUserAgent(privateContext));

        GetMethod get = new GetMethod(surl);

        try {
            client.executeMethod(get);

            int code = get.getStatusCode();
            if (code != HttpStatus.SC_OK) {
                throw new Exception("Failed to get content for URL [${surl}]: code [${code}]");
            }

            // read the properties from url
            Properties properties = (Properties) xwiki.parseGroovyFromPage("L10NCode.L10NFixedProperties");
            properties.load(get.getResponseBodyAsStream());

            return properties;
        } finally {
            get.releaseConnection();
        }
    }

    private XWikiDocument getXWikiDocumentFromURL(String surl) throws Exception
    {
        HttpClient client =
            com.xpn.xwiki.XWiki.getHttpClient(privateXWiki.getHttpTimeout(privateContext),
                privateXWiki.getHttpUserAgent(privateContext));

        GetMethod get = new GetMethod(surl);

        try {
            client.executeMethod(get);

            int code = get.getStatusCode();
            if (code != HttpStatus.SC_OK) {
                throw new Exception("Failed to get content for URL [${surl}]: code [${code}]");
            }

            // read the document from url
            XWikiDocument xdoc = new XWikiDocument();
            xdoc.fromXML(get.getResponseBodyAsStream());

            return xdoc;
        } finally {
            get.releaseConnection();
        }
    }

    private TranslationBundleReader getXWikiDocumentTranslationsFromURL(String surl) throws Exception
    {
        XWikiDocument xdoc = getXWikiDocumentFromURL(surl);

        return getTranslationsFromString(xdoc.getContent());
    }

    public Properties getPropertiesFromString(String content) throws IOException
    {
        Reader reader = new StringReader(content);
        Properties props = new Properties();
        props.load(reader);

        return props;
    }

    public TranslationBundleReader getTranslationsFromString(String content) throws IOException
    {
        Reader reader = new StringReader(content);
        TranslationBundleReader translations = new TranslationBundleReader();
        translations.load(reader);

        return translations;
    }

    private Properties getPropertiesFromWiki(String page, String language) throws XWikiException, IOException
    {
        XWikiDocument xdoc = xwiki.getDocument(page).getTranslatedDocument(language).getDocument();

        return getPropertiesFromString(xdoc.getContent());
    }

    private TranslationBundleReader getTranslationsFromWiki(String page, String language) throws XWikiException,
        IOException
    {
        XWikiDocument xdoc = xwiki.getDocument(page).getTranslatedDocument(language).getDocument();

        return getTranslationsFromString(xdoc.getContent());
    }

    /* import functions */
    public int importTranslationWikiPageFromURL(String app, String name, String language, String url) throws Exception
    {
        TranslationBundleReader translations = getXWikiDocumentTranslationsFromURL(url);

        int ret = importMap(app, name, language, translations);
        String dlang = getApplicationDefaultLanguage(app);
        if (!StringUtils.equals(dlang, language)) {
            prepareTranslations(app, name, language);
        } else {
            // remove dead default translations
            cleanDead(app, name, language, translations.keySet());
            clearCache(app, name, language);
        }

        return ret;
    }

    /* import functions */
    public int importWikiPageFromURL(String app, String name, String language, String surl) throws Exception
    {
        XWikiDocument xdocument = getXWikiDocumentFromURL(surl);

        Properties props = new Properties();
        props.put("title", xdocument.getTitle());
        props.put("content", xdocument.getContent());

        int ret = importMap(app, name, language, (Map) props);
        String dlang = getApplicationDefaultLanguage(app);
        if (!StringUtils.equals(dlang, language)) {
            prepareTranslations(app, name, language);
        } else {
            clearCache(app, name, language);
        }

        return ret;
    }

    /* import functions */
    public int importTranslationWikiPageFromWiki(String app, String name, String language, String pagename)
        throws XWikiException, IOException, QueryException
    {
        TranslationBundleReader translations = getTranslationsFromWiki(pagename, language);

        int ret = importMap(app, name, language, translations);
        String dlang = getApplicationDefaultLanguage(app);
        if (!StringUtils.equals(dlang, language)) {
            prepareTranslations(app, name, language);
        } else {
            // remove dead default translations
            cleanDead(app, name, language, translations.keySet());
            clearCache(app, name, language);
        }

        return ret;
    }

    /* import functions */
    public int importWikiPageFromWiki(String app, String name, String language, String pagename) throws XWikiException,
        QueryException
    {
        Document document = xwiki.getDocument(pagename).getTranslatedDocument();

        Properties props = new Properties();
        props.put("title", document.getTitle());
        props.put("content", document.getContent());

        int ret = importMap(app, name, language, (Map) props);
        String dlang = getApplicationDefaultLanguage(app);
        if (!StringUtils.equals(dlang, language)) {
            prepareTranslations(app, name, language);
        } else {
            clearCache(app, name, language);
        }

        return ret;
    }

    /* import functions */
    public int importApplicationResourcesFromURL(String app, String name, String language, String surl)
        throws Exception
    {
        // read the translations
        TranslationBundleReader translations = getTranslationsFromURL(surl);

        int ret = importMap(app, name, language, translations);
        String dlang = getApplicationDefaultLanguage(app);
        if (!StringUtils.equals(dlang, language)) {
            prepareTranslations(app, name, language);
        } else {
            // remove dead default translations
            cleanDead(app, name, language, translations.keySet());
            clearCache(app, name, language);
        }

        return ret;
    }

    public int importMap(String app, String name, String language, Map&lt;String, ?&gt; map) throws XWikiException
    {
        int counter = 0;

        String dlang = getApplicationDefaultLanguage(app);

        for (Map.Entry&lt;String, ?&gt; entry : map.entrySet()) {
            String key = entry.getKey();

            // some translation pages use this to display the trans page nicely in xwiki
            // we should ignore the key
            if (key.equals("{table}")) {
                continue;
            }

            if (key.equals("notranslationsmarker")) {
                break;
            }

            String value;
            String comment;
            Boolean deprecated;
            String newKey;

            if (entry.getValue() instanceof TranslationBundleReader.Translation) {
                TranslationBundleReader.Translation translation =
                    (TranslationBundleReader.Translation) entry.getValue();
                value = translation.getValue();
                comment = translation.getComment();
                deprecated = translation.isDeprecated();
                newKey = translation.getNewKey();
            } else {
                value = (String) entry.getValue();
                comment = null;
                deprecated = null;
                newKey = null;
            }

            String pagename = "${app}." + getPageName(name, key, language);
            Document doc = xwiki.getDocument(pagename);
            Document ddoc;
            if (language != dlang) {
                ddoc = xwiki.getDocument("${app}." + getPageName(name, key, dlang));
            } else {
                ddoc = doc;
            }

            boolean needSave = false;

            com.xpn.xwiki.api.Object translation = doc.getObject("L10NCode.TranslationClass");
            if (translation == null) {
                translation = doc.newObject("L10NCode.TranslationClass");
                needSave = true;
            }

            // initial values

            needSave |= update(doc, translation, T_PROP_KEY, key);
            needSave |= update(doc, translation, T_PROP_LANGUAGE, language);
            if (translation.getProperty(T_PROP_STATUS) == null) {
                translation.set(T_PROP_STATUS, "none");
                needSave = true;
            }
            needSave |= update(doc, translation, T_PROP_NAME, name);

            if (!StringUtils.equals(doc.getContent(), "{{include document=\"L10NCode.TranslationClassSheet20\"/}}")) {
                doc.setContent("{{include document=\"L10NCode.TranslationClassSheet20\"/}}");
            }
            if (doc.getSyntax() != Syntax.XWIKI_2_0) {
                doc.setSyntax(Syntax.XWIKI_2_0);
            }

            // update

            if (language == dlang) {
                needSave |= update(doc, translation, T_PROP_ORIGINALTEXT, value);
            } else {
                needSave |= update(doc, translation, T_PROP_TRANSLATEDTEXT, value);

                needSave |= update(doc, translation, T_PROP_ORIGINALTEXT, ddoc.getValue(T_PROP_ORIGINALTEXT));
            }

            needSave |=
                update(doc, translation, T_PROP_COMMENT, comment != null &amp;&amp; comment.length() &lt; 255 ? comment : "");
            needSave |= update(doc, translation, T_PROP_DEPRECATED, deprecated == Boolean.TRUE ? 1 : 0);
            needSave |= update(doc, translation, T_PROP_NEWKEY, newKey != null ? newKey : "");

            // Save

            if (needSave) {
                saveAsTranslator(doc, "Imported");
                ++counter;
            }
        }

        clearCache(app, name);

        return counter;
    }

    public void cleanDead(String app, String name, String language, Collection&lt;String&gt; validKeys) throws XWikiException
    {
        List&lt;Object[]&gt; keysToRemove = getKeysToRemove(app, name, language, validKeys);

        for (Object[] key : keysToRemove) {
            xwiki.getDocument((String) key[1]).delete();
        }
    }

    public List&lt;Object[]&gt; getKeysToRemove(String app, String name, String language, Collection&lt;String&gt; validKeys)
        throws XWikiException
    {
        List&lt;Object[]&gt; keysToRemove = new ArrayList&lt;Object[]&gt;();

        int start = 0;
        List&lt;Object[]&gt; keys = null;
        while (keys == null || keys.size() == 100) {
            keys = getKeysAndDocNames(app, name, language, 100, start);
            keysToRemove.addAll(getKeysToRemove(app, name, language, validKeys, keys));

            start += 100;
        }

        return keysToRemove;
    }

    public List&lt;Object[]&gt; getKeysToRemove(String app, String name, String language, Collection&lt;String&gt; validKeys,
        Collection&lt;Object[]&gt; keys)
    {
        List&lt;Object[]&gt; keysToRemove = new ArrayList&lt;Object[]&gt;();

        for (Object[] key : keys) {
            if (!validKeys.contains(key[0])) {
                keysToRemove.add(key);
            }
        }

        return keysToRemove;
    }

    public List&lt;Object[]&gt; getKeysAndDocNames(String app, String name, String language, int nb, int start)
        throws XWikiException
    {
        String sql =
            "select distinct propkey.value, obj.name from BaseObject as obj, StringProperty as propname, StringProperty as proplang, StringProperty as propkey where obj.className='L10NCode.TranslationClass' and obj.id=propname.id.id and propname.id.name='name' and propname.value='${name}' and obj.id=proplang.id.id and proplang.id.name='language' and proplang.value='${language}' and obj.id=propkey.id.id and propkey.id.name='key' order by propkey.value";

        return this.privateXWiki.search(sql, nb, start, this.privateContext);
    }

    public String exportTranslationFile(String app, String name, String language) throws Exception
    {
        Document transfiledoc = xwiki.getDocument(name);
        String type = (String) transfiledoc.getValue("type");

        return exportTranslationFile(app, name, language, type);
    }

    public String exportTranslationFile(String app, String name, String language, String type) throws Exception
    {
        return exportTranslationFile(null, app, name, language, type);
    }

    public String exportTranslationFile(ZipOutputStream zos, String app, String name, String language, String type)
        throws Exception
    {
        if (language == null) {
            return exportTranslationFileLanguages(app, name, type);
        } else {
            if (type.equals("resource")) {
                return exportApplicationResources(zos, app, name, language, true);
            } else if (type.equals("exportedwikipage")) {
                return exportWikiPage(zos, app, name, language);
            } else if (type.equals("exportedwikitrans")) {
                return exportTranslationWikiPage(zos, app, name, language);
            } else if (type.equals("wikipage")) {
                return exportWikiPage(zos, app, name, language);
            } else if (type.equals("wikitrans")) {
                return exportTranslationWikiPage(zos, app, name, language);
            } else {
                return null;
            }
        }
    }

    public String exportTranslationFileLanguages(String app, String name, String type) throws Exception
    {
        // set mime type
        context.getResponse().setContentType("application/zip");
        // force download request
        context.getResponse().setHeader("Content-Disposition", "attachment; filename=${app}_${name}.zip");

        ZipOutputStream zos = new ZipOutputStream(context.getResponse().getOutputStream());

        for (String language : getApplicationLanguages(app)) {
            exportTranslationFile(zos, app, name, language, type);
        }

        zos.setComment("Language pack for application [${app}] and translation file [${name}]");

        // Finish ZIP file
        zos.finish();
        zos.flush();

        context.setFinished(true);

        return null;
    }

    /**
     * This functions will allow to transform automatically ' into '' when a translations contains a apostrophe and a
     * parameter at the same time which is necessary
     */
    public String escapeQuotes(String value)
    {
        if (value.matches(".*\\{[0-9]\\}.*")) {
            return value.replaceAll("'", "''").replaceAll("''''", "''");
        } else {
            return value;
        }
    }

    public String exportApplicationResources(ZipOutputStream zos, String app, String name, String language, boolean esc)
        throws XWikiException, IOException
    {
        return exportApplicationResources(zos, app, name, language, esc, true);
    }

    public String exportApplicationResources(ZipOutputStream zos, String app, String name, String language,
        boolean esc, boolean contentType) throws XWikiException, IOException
    {
        List&lt;String[]&gt; translist = getAllTranslationsValues(app, name, language, 0, 0);
        Properties props = (Properties) xwiki.parseGroovyFromPage("L10NCode.L10NSortedPropertiesGroovy");

        for (String[] transentry : translist) {
            String key = transentry[0];
            String validtrans = transentry[2];
            if (StringUtils.isEmpty(validtrans)) {
                validtrans = transentry[1];
            }

            if (validtrans != null &amp;&amp; validtrans != "") {
                props.put(key, escapeQuotes(validtrans).replace("\r\n", "\n"));
            }
        }

        if (props.size() &gt; 0) {
            if (zos == null) {
                if (esc) {
                    OutputStream os = new ByteArrayOutputStream();
                    props.store(os,
                        "# XWiki Translation for language ${language} generated from http://www.l10n.xwiki.org");

                    if (contentType) {
                        context.getResponse().setContentType("text/plain");
                    }

                    return os.toString();
                } else {
                    Writer writer = new StringWriter();
                    props.store(writer,
                        "# XWiki Translation for language ${language} generated from http://www.l10n.xwiki.org");

                    if (contentType) {
                        context.getResponse().setContentType("text/plain");
                    }

                    return writer.toString();
                }
            } else {
                if (!props.isEmpty()) {
                    String resourceFileName = getResourceFileName(name);

                    int index = resourceFileName.lastIndexOf('.');

                    StringBuilder zipEntryName = new StringBuilder();
                    zipEntryName.append(resourceFileName.substring(0, index));
                    zipEntryName.append('_');
                    zipEntryName.append(language);
                    zipEntryName.append(resourceFileName.substring(index));

                    ZipEntry zipentry = new ZipEntry(zipEntryName.toString());
                    zos.putNextEntry(zipentry);

                    props.store(zos,
                        "# XWiki Translation for language ${language} generated from http://www.l10n.xwiki.org");

                    zos.closeEntry();
                }

                return null;
            }
        }

        return null;
    }

    public String getResourceFileName(String name) throws XWikiException
    {
        Document transfiledoc = xwiki.getDocument(name);
        com.xpn.xwiki.api.Object transfileobj = transfiledoc.getObject("L10NCode.TranslationFileClass");

        String url = (String) transfiledoc.getValue("url", transfileobj);

        return url.substring(url.lastIndexOf('/') + 1);
    }

    public String exportWikiPage(ZipOutputStream zos, String app, String name, String language) throws Exception
    {
        List&lt;String[]&gt; translist = getAllTranslationsValues(app, name, language, 0, 0);
        String content = null;
        String title = null;
        for (String[] transentry : translist) {
            String key = transentry[0];
            String validtrans = transentry[2];
            if (StringUtils.isEmpty(validtrans)) {
                validtrans = transentry[1];
            }

            if (validtrans != null &amp;&amp; validtrans != "") {
                if (key.equals("content")) {
                    // make sure to use the proper line ending
                    content = validtrans.replace("\r\n", "\n").replace('\r', '\n');
                } else if (key.equals("title")) {
                    title = validtrans;
                }
            }
        }

        return exportWikiPage(zos, title, content, app, name, language);
    }

    public String exportTranslationWikiPage(ZipOutputStream zos, String app, String name, String language)
        throws Exception
    {
        String properties = exportApplicationResources(null, app, name, language, false, false);

        return exportWikiPage(zos, null, properties, app, name, language);
    }

    public String exportWikiPage(ZipOutputStream zos, String title, String content, String app, String name,
        String language) throws Exception
    {
        String export = "";

        if (content != null) {
            Document transfiledoc = xwiki.getDocument(name);
            com.xpn.xwiki.api.Object transfileobj = transfiledoc.getObject("L10NCode.TranslationFileClass");

            // Duplicate default document
            XWikiDocument exportDocument = getXWikiDocumentFromURL((String) transfiledoc.getValue("url", transfileobj));

            // Remove objects
            exportDocument.setXObjects(Collections.EMPTY_MAP);

            // Remove attachments
            exportDocument.setAttachmentList(Collections.EMPTY_LIST);

            exportDocument.setTranslation(1);
            exportDocument.setLanguage(language);

            // put the translation in the document content
            if (title != null) {
                exportDocument.setTitle(title);
            }
            exportDocument.setContent(content);

            // export the document
            export = exportDocument.toXML(privateContext);

            if (zos == null) {
                // set mime type
                context.getResponse().setContentType("text/xml");
                // force download request
                StringBuilder headerValue = new StringBuilder();
                headerValue.append("attachment; filename=");
                headerValue.append(exportDocument.getName());
                headerValue.append('.');
                headerValue.append(language);
                headerValue.append(".xml");

                //context.getResponse().setHeader("Content-Disposition", headerValue.toString());
            } else {
                StringBuilder zipEntryName = new StringBuilder();
                for (EntityReference referenceElement : exportDocument.documentReference.getReversedReferenceChain()) {
                  if (referenceElement.type == EntityType.SPACE || referenceElement.type == EntityType.DOCUMENT) {
                    if (zipEntryName.length() &gt; 0) {
                      zipEntryName.append('/');
                    }
                    zipEntryName.append(referenceElement.name);
                  }
                }
                zipEntryName.append('.');
                zipEntryName.append(language);
                zipEntryName.append(".xml");

                ZipEntry zipentry = new ZipEntry(zipEntryName.toString());
                zos.putNextEntry(zipentry);

                zos.write(export.getBytes(xwiki.getEncoding()));

                zos.closeEntry();
            }
        }

        return export;
    }

    /* translations management functions */

    public String getOriginalTranslation(Document transdoc) throws XWikiException
    {
        String app = transdoc.getSpace();
        String dlang = getApplicationDefaultLanguage(app);
        String pagename =
            getPageName((String) transdoc.getValue(T_PROP_NAME), (String) transdoc.getValue(T_PROP_KEY), dlang);
        pagename = "${app}.${pagename}";

        Document newdoc = xwiki.getDocument(pagename);
        newdoc.use("L10NCode.TranslationClass");

        return (String) newdoc.getValue(T_PROP_ORIGINALTEXT);
    }

    public Map&lt;String, Document&gt; getTranslations(String app, String name, String language) throws XWikiException
    {
        String sql =
            ", BaseObject as obj, StringProperty as prop, StringProperty as proplang where doc.web='${app}' and doc.fullName=obj.name and obj.className='L10NCode.TranslationClass' and obj.id=prop.id.id and prop.id.name='name' and prop.value='${name}' and obj.id=proplang.id.id and proplang.id.name='language' and proplang.value='${language}'";

        List&lt;String&gt; list = xwiki.searchDocuments(sql);
        Map&lt;String, Document&gt; map = new HashMap&lt;String, Document&gt;();
        for (String docname : list) {
            Document doc = xwiki.getDocument(docname);
            doc.use("L10NCode.TranslationClass");
            String key = (String) doc.getValue(T_PROP_KEY);
            map.put(key, doc);
        }

        return map;
    }

    public Collection&lt;String&gt; getTranslationKeys(String app, String name, String language) throws QueryException
    {
        String sql =
            "select translation.key from Document as doc, doc.object(L10NCode.TranslationClass) as translation where doc.web=:app and translation.name=:name and translation.language=:language";

        Query query = getQueryManager().createQuery(sql, Query.XWQL);

        query.bindValue("app", app);
        query.bindValue("name", name);
        query.bindValue("language", language);

        return query.execute();
    }

    /**
     * This will look for all translations available in language sourceLanguage not available in language
     */
    public List&lt;String&gt; checkTranslations(String app, String name, String sourceLanguage, String language)
        throws QueryException
    {
        Collection&lt;String&gt; sourceKeys = getTranslationKeys(app, name, sourceLanguage);
        Collection&lt;String&gt; targetKeys = getTranslationKeys(app, name, language);
        List&lt;String&gt; result = new ArrayList&lt;String&gt;();
        for (String key : sourceKeys) {
            if (!targetKeys.contains(key)) {
                result.add(key);
            }
        }

        return result;
    }

    /*
     * This will import default language and create the missing pages for other languages for all the resources of all
     * the applications
     */
    public void reloadApplications() throws Exception
    {
        for (String appdocname : getApplications()) {
            try {
                reloadApplication(xwiki.getDocument(appdocname).getSpace());
            } catch (Exception e) {
                LOGGER.error("Failed to reload application " + appdocname, e);
            }
        }
    }

    /*
     * This will import default language and create the missing pages for other languages for all the resources of the
     * provided application
     */
    public void reloadApplication(String app) throws Exception
    {
        for (Map&lt;String, Object&gt; transfile : getTranslationsFiles(app)) {
            String docname = (String) transfile.get("page");

            try {
                reloadApplication(app, docname);
            } catch (Exception e) {
                LOGGER.error("Failed to reload translation resource " + docname, e);
            }
        }
    }

    public void reloadApplication(String app, String docname) throws Exception
    {
        Document appdoc = xwiki.getDocument(docname);
        String lang = getApplicationDefaultLanguage(appdoc);
        String url = (String) appdoc.getValue("url");

        // import default language
        importTranslations(app, docname, lang, url);

        // prepare translations
        prepareTranslations(app, docname);
    }

    /*
     * This will create the missing pages in your languages versus the english language
     */
    public int prepareTranslations(String app, String docname) throws XWikiException, QueryException
    {
        int counter = 0;

        for (String tlang : getApplicationLanguages(app)) {
            counter += prepareTranslations(app, docname, tlang);
        }

        return counter;
    }

    /**
     * This will create the missing pages in your language versus the default language.
     */
    public int prepareTranslations(String app, String name, String language) throws XWikiException, QueryException
    {
        String defaultLocale = getApplicationDefaultLanguage(app);

        int counter = 0;
        Set&lt;String&gt; defaultKeys = new HashSet&lt;String&gt;(getTranslationKeys(app, name, defaultLocale));
        for (String key : defaultKeys) {
            Document defaultDoc = xwiki.getDocument("${app}." + getPageName(name, key, defaultLocale));
            Document doc = xwiki.getDocument("${app}." + getPageName(name, key, language));

            com.xpn.xwiki.api.Object dtranslation = defaultDoc.getObject("L10NCode.TranslationClass");

            boolean needSave = false;

            com.xpn.xwiki.api.Object translation = doc.getObject("L10NCode.TranslationClass");
            if (translation == null) {
                translation = doc.newObject("L10NCode.TranslationClass");
                needSave = true;
            }

            // copied from default language

            needSave |= update(doc, translation, T_PROP_KEY, defaultDoc.getValue(T_PROP_KEY, dtranslation));
            needSave |=
                update(doc, translation, T_PROP_ORIGINALTEXT, defaultDoc.getValue(T_PROP_ORIGINALTEXT, dtranslation));
            needSave |= update(doc, translation, T_PROP_COMMENT, defaultDoc.getValue(T_PROP_COMMENT, dtranslation));

            // initial value

            needSave |= update(doc, translation, T_PROP_NAME, name);
            needSave |= update(doc, translation, T_PROP_LANGUAGE, language);
            if (!StringUtils.equals(doc.getContent(), "{{include document=\"L10NCode.TranslationClassSheet20\"/}}")) {
                doc.setContent("{{include document=\"L10NCode.TranslationClassSheet20\"/}}");
                needSave = true;
            }
            if (doc.getSyntax() != Syntax.XWIKI_2_0) {
                doc.setSyntax(Syntax.XWIKI_2_0);
                needSave = true;
            }

            // default values

            String translatedtext;
            Property transtatedtextProperty = translation.getProperty(T_PROP_TRANSLATEDTEXT);
            if (transtatedtextProperty == null) {
                translatedtext = "";
                translation.set(T_PROP_TRANSLATEDTEXT, "");
                needSave = true;
            } else {
                translatedtext = (String) transtatedtextProperty.getValue();
            }
            if (translation.getProperty(T_PROP_STATUS) == null) {
                translation.set(T_PROP_STATUS, "none");
                needSave = true;
            }

            // copy deprecated keys if needed

            boolean isDeprecated = ObjectUtils.equals(defaultDoc.getValue(T_PROP_DEPRECATED, dtranslation), 1);
            String newKey = (String) defaultDoc.getValue(T_PROP_NEWKEY, dtranslation);

            if (isDeprecated) {
                if (!ObjectUtils.equals(doc.getValue(T_PROP_DEPRECATED, translation), 1)) {
                    translation.set(T_PROP_DEPRECATED, 1);

                    needSave = true;

                    // Update new translation key
                    if (StringUtils.isNotEmpty(translatedtext) &amp;&amp; StringUtils.isNotEmpty(newKey)) {
                        // copy translation to new key
                        Document newKeyDoc = xwiki.getDocument("${app}." + getPageName(name, newKey, language));
                        com.xpn.xwiki.api.Object newKeyTranslation = newKeyDoc.getObject("L10NCode.TranslationClass");

                        boolean needSaveNewKeyDoc = false;
                        if (newKeyTranslation == null) {
                            newKeyTranslation = newKeyDoc.newObject("L10NCode.TranslationClass");
                            needSaveNewKeyDoc = true;
                        }

                        if (StringUtils.isEmpty((String) newKeyDoc.getValue(T_PROP_TRANSLATEDTEXT, newKeyTranslation))) {
                            newKeyTranslation.set(T_PROP_TRANSLATEDTEXT, translatedtext);
                            needSaveNewKeyDoc = true;
                        }

                        if (needSaveNewKeyDoc) {
                            saveAsTranslator(newKeyDoc, "Copied from deprecated key");
                        }
                    }
                }
            } else {
                needSave |= update(doc, translation, T_PROP_DEPRECATED, 0);
            }

            needSave |= update(doc, translation, T_PROP_NEWKEY, newKey);

            // Save
            if (needSave) {
                saveAsTranslator(doc, "Prepared");
                ++counter;
            }
        }

        // Update dead translations
        String sql =
            "select translation.key from Document as doc, doc.object(L10NCode.TranslationClass) as translation where doc.web=:app and translation.name=:name and translation.language=:language and translation.status&lt;&gt;:status";
        Query query = getQueryManager().createQuery(sql, Query.XWQL);
        query.bindValue("app", app);
        query.bindValue("name", name);
        query.bindValue("language", language);
        query.bindValue("status", "dead");
        for (String key : query.&lt;String&gt;execute()) {
            if (!defaultKeys.contains(key)) {
                Document doc = xwiki.getDocument("${app}." + getPageName(name, key, language));
                com.xpn.xwiki.api.Object translation = doc.getObject("L10NCode.TranslationClass");
                translation.set(T_PROP_STATUS, "dead");
                saveAsTranslator(doc, "Prepared");
            }
        }

        // Clear related cache
        clearCache(app, name, language);

        return counter;
    }

    protected boolean update(Document document, com.xpn.xwiki.api.Object object, String fieldName, Object value)
    {
        if (ObjectUtils.notEqual(value, document.getValue(fieldName, object))) {
            object.set(fieldName, value);

            return true;
        }

        return false;
    }

    // ////////////////////////////////////////////////////////////////
    // Search translations
    // ////////////////////////////////////////////////////////////////

    private void saveAsTranslator(Document doc, String comment) throws XWikiException
    {
        DocumentReference currentUser = privateContext.getUserReference();
        try {
            // Make sure pages are created with a generic user
            privateContext.setUser(TRANSLATOR_FULL_NAME);

            doc.save(comment, true);
        } finally {
            privateContext.setUserReference(currentUser);
        }
    }

    /*
     * This will look for all translations
     */
    public List&lt;String&gt; getAllTranslations(String app, String name, String language, int limit, int offset)
        throws XWikiException, QueryException
    {
        String sql =
            "from doc.object(L10NCode.TranslationClass) as translation where doc.web=:app and translation.name=:name and translation.language=:language and translation.status &lt;&gt; 'dead' order by translation.key";

        Query query = getQueryManager().createQuery(sql, Query.XWQL);

        query.bindValue("app", app);
        query.bindValue("name", name);
        query.bindValue("language", language);
        query.setLimit(limit);
        query.setOffset(offset);

        return query.execute();
    }

    /*
     * Does not return dead translations.
     * @name the translation resource name (App.FileName)
     * @language the language code for which to get the translations
     */
    public List&lt;String[]&gt; getAllTranslationsValues(String app, String name, String language, int nb, int start)
        throws XWikiException
    {
        String dlang = getApplicationDefaultLanguage(app);
        String defaultsql =
            "select propkey.value from BaseObject as obj, StringProperty as prop, StringProperty as proplang, StringProperty as propkey where obj.className='L10NCode.TranslationClass' and obj.id=prop.id.id and prop.id.name='name' and prop.value='${name}' and obj.id=proplang.id.id and proplang.id.name='language' and proplang.value='${dlang}' and obj.id=propkey.id.id and propkey.id.name='key'";

        // TODO: improve using a JOIN
        String sql =
            "select propkey.value, propvalue.value from BaseObject as obj, StringProperty as propname, StringProperty as proplang, StringProperty as propkey, LargeStringProperty as propvalue where obj.className='L10NCode.TranslationClass' and obj.id=propname.id.id and propname.id.name='name' and propname.value='${name}' and obj.id=proplang.id.id and proplang.id.name='language' and proplang.value='${language}' and obj.id=propvalue.id.id and propvalue.id.name='translatedtext' and obj.id=propkey.id.id and propkey.id.name='key' and propkey.value in (${defaultsql}) order by propkey.value";

        List&lt;Object[]&gt; translations = this.privateXWiki.search(sql, nb, start, this.privateContext);

        Map&lt;String, String[]&gt; map = new LinkedHashMap&lt;String, String[]&gt;(translations.size());

        for (Object[] tr : translations) {
            String key = (String) tr[0];
            String value = (String) tr[1];

            map.put(key, Arrays.&lt;String&gt;asList(key, value, null).toArray(new String[0]));
        }

        return new ArrayList&lt;String[]&gt;(map.values());
    }

    /*
     * This will look for all translations that are empty
     */
    public List getEmptyTranslations(String app, String name, String language, int limit, int offset)
        throws XWikiException, QueryException
    {
        String sql =
            "from doc.object(L10NCode.TranslationClass) as translation where doc.web=:app and translation.name=:name and translation.language=:language and (translation.translatedtext='' or translation.translatedtext is null) and (translation.deprecated = 0 or translation.deprecated is null) and translation.status &lt;&gt; 'dead' order by translation.key";

        Query query = getQueryManager().createQuery(sql, Query.XWQL);

        query.bindValue("app", app);
        query.bindValue("name", name);
        query.bindValue("language", language);
        query.setLimit(limit);
        query.setOffset(offset);

        return query.execute();
    }

    /*
     * This will look for all translations that are empty
     */
    public List getToReviewTranslations(String app, String name, String language, int limit, int offset)
        throws QueryException
    {
        String sql =
            "from doc.object(L10NCode.TranslationClass) as translation where doc.web=:app and translation.name=:name and translation.language=:language and translation.translatedtext &lt;&gt; '' and translation.translatedtext is not null and translation.status &lt;&gt; 'validated' and translation.status &lt;&gt; 'dead' and (translation.deprecated = 0 or translation.deprecated is null) order by translation.key";

        Query query = getQueryManager().createQuery(sql, Query.XWQL);

        query.bindValue("app", app);
        query.bindValue("name", name);
        query.bindValue("language", language);
        query.setLimit(limit);
        query.setOffset(offset);

        return query.execute();
    }

    /*
     * This will look for all translations that are empty, starting from the specified key, without including the
     * specified key. Key prefixes can also be used.
     */
    public List getToReviewTranslationsFromKey(String app, String name, String language, int limit, int offset,
        String startKey) throws QueryException
    {
        String sql =
            "from doc.object(L10NCode.TranslationClass) as translation where doc.web=:app and translation.name=:name and translation.language=:language and translation.translatedtext &lt;&gt; '' and translation.translatedtext is not null and translation.status &lt;&gt; 'validated' and translation.status &lt;&gt; 'dead' and translation.key &gt; :startkey and (translation.deprecated = 0 or translation.deprecated is null) order by translation.key";

        Query query = getQueryManager().createQuery(sql, Query.XWQL);

        query.bindValue("app", app);
        query.bindValue("name", name);
        query.bindValue("language", language);
        query.bindValue("startkey", startKey);
        query.setLimit(limit);
        query.setOffset(offset);

        return query.execute();
    }

    /*
     * This will look for all translations that are outdated
     */
    public List getOutdatedTranslations(String app, String name, String language, int nb, int start)
        throws XWikiException
    {
        String dlang = getApplicationDefaultLanguage(app);
        String sql =
            ", BaseObject as obj, StringProperty as prop, StringProperty as proplang, StringProperty as propkey, LargeStringProperty propcontent, BaseObject as enobj, StringProperty as enprop, StringProperty as enproplang, StringProperty as enpropkey, LargeStringProperty enpropcontent where doc.web='${app}' and doc.fullName=obj.name and obj.className='L10NCode.TranslationClass' and obj.id=prop.id.id and prop.id.name='name' and prop.value='${name}' and obj.id=proplang.id.id and proplang.id.name='language' and proplang.value='${language}' and propcontent.id.id=obj.id and propcontent.id.name='originaltext' and obj.id=propkey.id.id and propkey.id.name='key' and enobj.className='L10NCode.TranslationClass' and enobj.id=enprop.id.id and enprop.id.name='name' and enprop.value='${name}' and enobj.id=enproplang.id.id and enproplang.id.name='language' and enproplang.value='${dlang}' and enpropcontent.id.id=enobj.id and enpropcontent.id.name='originaltext' and enobj.id=enpropkey.id.id and enpropkey.id.name='key' and propkey.value=enpropkey.value and enpropcontent.value&lt;&gt;propcontent.value order by propkey.value";

        return xwiki.searchDocuments(sql, nb, start);
    }

    /*
     * This will look for all translations that are non existent
     */
    public List getNonexistentTranslations(String app, String name, String language, int nb, int start)
        throws XWikiException
    {
        String dlang = getApplicationDefaultLanguage(app);
        String defaultsql =
            "select propkey.value from BaseObject as obj, StringProperty as prop, StringProperty as proplang, StringProperty as propkey where obj.className='L10NCode.TranslationClass' and obj.id=prop.id.id and prop.id.name='name' and prop.value='${name}' and obj.id=proplang.id.id and proplang.id.name='language' and proplang.value='${dlang}' and obj.id=propkey.id.id and propkey.id.name='key'";

        String sql =
            ", BaseObject as obj, StringProperty as prop, StringProperty as proplang, StringProperty as propkey where doc.web='${app}' and doc.fullName=obj.name and obj.className='L10NCode.TranslationClass' and obj.id=prop.id.id and prop.id.name='name' and prop.value='${name}' and obj.id=proplang.id.id and proplang.id.name='language' and proplang.value='${language}' and obj.id=propkey.id.id and propkey.id.name='key' and propkey.value not in (${defaultsql}) order by propkey.value";

        return xwiki.searchDocuments(sql, nb, start);
    }

    public long count(String sql) throws QueryException
    {
        return count(sql, null);
    }

    public long count(String sql, List&lt;?&gt; values) throws QueryException
    {
        return count(getQueryManager().createQuery(sql, Query.HQL), values);
    }

    public long countXWQL(String sql, List&lt;?&gt; values) throws QueryException
    {
        return count(getQueryManager().createQuery(sql, Query.XWQL), values);
    }

    public long count(Query query, List&lt;?&gt; values) throws QueryException
    {
        if (values != null) {
            query.bindValues((List) values);
        }

        lastsql = query.getStatement();
        List&lt;Object&gt; result = query.execute();
        if (result.size() == 0) {
            return 0;
        } else {
            return (Long) result.get(0);
        }
    }

    /*
     * This will count the translations in the default language
     */
    public long countDefaultLanguageTranslations(String app, String name) throws XWikiException, QueryException
    {
        Long result = (Long) getFromCache(countCache, app, name, "defaultlanguage", null, null, null, true);
        if (result == null) {
            result = countTranslations(app, name, getApplicationDefaultLanguage(app));
        }

        return result;
    }

    /*
     * This will count the translations in the default language
     */
    public long countTranslations(String app, String name, String language) throws XWikiException, QueryException
    {
        String sql =
            "select count(doc.id) from Document as doc, doc.object(L10NCode.TranslationClass) as translation where doc.web=:app and translation.name=:name and translation.language=:language";

        Query query = getQueryManager().createQuery(sql, Query.XWQL);

        query.bindValue("app", app);
        query.bindValue("name", name);
        query.bindValue("language", language);

        List list = query.execute();

        return list.isEmpty() ? 0 : (Long) list.get(0);
    }

    /*
     * This will look for all translations that are empty
     */
    public long countAllEmptyTranslations(String app, String name) throws XWikiException, QueryException
    {
        Long result = (Long) getFromCache(countEmptyCache, app, name, null, null, null, null, true);
        if (result == null) {
            String sql =
                "select count(*) from BaseObject as obj, StringProperty as prop, LargeStringProperty propcontent where obj.className='L10NCode.TranslationClass' and obj.id=prop.id.id and prop.id.name='name' and prop.value='${name}' and propcontent.id.id=obj.id and propcontent.id.name='translatedtext' and (propcontent.value='' or propcontent.value is null)";
            result = count(sql);
            countEmptyCache.put("${app}_${name}", result);

            addToCache(countEmptyCache, result, app, name, null, null, null, null, true);
        }

        return result;
    }

    /*
     * This will look for all translations that must be reviewed
     */
    public long countAllToReviewTranslations(String app, String name) throws XWikiException, QueryException
    {
        Long result = (Long) getFromCache(countToReviewCache, app, name, null, null, null, null, true);
        if (result == null) {
            String dlang = getApplicationDefaultLanguage(app);
            String sql =
                "select count(*) from BaseObject as obj, StringProperty as prop, StringProperty propreview, StringProperty as proplang, LargeStringProperty propcontent where obj.className='L10NCode.TranslationClass' and obj.id=prop.id.id and prop.id.name='name' and prop.value='${name}' and propreview.id.id=obj.id and propreview.id.name='status' and propreview.value &lt;&gt; 'validated' and propcontent.id.id=obj.id and propcontent.id.name='translatedtext' and propcontent.value &lt;&gt; '' and propcontent.value is not null and proplang.id.id=obj.id and proplang.id.name='language' and proplang.value&lt;&gt; '${dlang}'";
            result = count(sql);

            addToCache(countToReviewCache, result, app, name, null, null, null, null, true);
        }

        return result;
    }

    /*
     * This will look for all translations that are outdated
     */
    public long countAllOutdatedTranslations(String app, String name) throws XWikiException, QueryException
    {
        Long result = (Long) getFromCache(countOutdatedCache, app, name, null, null, null, null, true);
        if (result == null) {
            String dlang = getApplicationDefaultLanguage(app);
            String sql =
                "select count(*) from XWikiDocument as doc, BaseObject as obj, StringProperty as prop, StringProperty as propkey, LargeStringProperty propcontent, BaseObject as enobj, StringProperty as enprop, StringProperty as enproplang, StringProperty as enpropkey, LargeStringProperty enpropcontent where doc.web='${app}' and doc.fullName=obj.name and obj.className='L10NCode.TranslationClass' and obj.id=prop.id.id and prop.id.name='name' and prop.value='${name}' and propcontent.id.id=obj.id and propcontent.id.name='originaltext' and obj.id=propkey.id.id and propkey.id.name='key' and enobj.className='L10NCode.TranslationClass' and enobj.id=enprop.id.id and enprop.id.name='name' and enprop.value='${name}' and enobj.id=enproplang.id.id and enproplang.id.name='language' and enproplang.value='${dlang}' and enpropcontent.id.id=enobj.id and enpropcontent.id.name='originaltext' and enobj.id=enpropkey.id.id and enpropkey.id.name='key' and propkey.value=enpropkey.value and enpropcontent.value&lt;&gt;propcontent.value";
            result = count(sql);

            addToCache(countOutdatedCache, result, app, name, null, null, null, null, true);
        }

        return result;
    }

    /*
     * This will look for all translations that are empty
     */
    public long countEmptyTranslations(String app, String name, String language) throws XWikiException, QueryException
    {
        String sql =
            "select count(translation.key) from Document as doc, doc.object(L10NCode.TranslationClass) as translation where doc.web=:app and translation.name=:name and translation.language=:language and (translation.translatedtext='' or translation.translatedtext is null) and (translation.deprecated = 0 or translation.deprecated is null) and translation.status &lt;&gt; 'dead' order by translation.key";

        Query query = getQueryManager().createQuery(sql, Query.XWQL);

        query.bindValue("app", app);
        query.bindValue("name", name);
        query.bindValue("language", language);

        List list = query.execute();

        return list.isEmpty() ? 0 : (Long) list.get(0);
    }

    /*
     * This will look for all translations that need to be reviewed
     */
    public long countToReviewTranslations(String app, String name, String language) throws XWikiException,
        QueryException
    {
        String sql =
            "select count(translation.key) from Document as doc, doc.object(L10NCode.TranslationClass) as translation where doc.web=:app and translation.name=:name and translation.language=:language and translation.translatedtext &lt;&gt; '' and translation.translatedtext is not null and translation.status &lt;&gt; 'validated' and (translation.deprecated = 0 or translation.deprecated is null) and translation.status &lt;&gt; 'dead' order by translation.key";

        Query query = getQueryManager().createQuery(sql, Query.XWQL);

        query.bindValue("app", app);
        query.bindValue("name", name);
        query.bindValue("language", language);

        List list = query.execute();

        return list.isEmpty() ? 0 : (Long) list.get(0);
    }

    /*
     * This will look for all translations that are outdated
     */
    public long countOutdatedTranslations(String app, String name, String language) throws XWikiException,
        QueryException
    {
        Long result = (Long) getFromCache(countOutdatedCache, app, name, language, null, null, null, true);
        if (result == null) {
            String dlang = getApplicationDefaultLanguage(app);
            String sql =
                "select count(doc.id) from XWikiDocument as doc, BaseObject as obj, StringProperty as prop, StringProperty as proplang, StringProperty as propkey, LargeStringProperty propcontent, BaseObject as enobj, StringProperty as enprop, StringProperty as enproplang, StringProperty as enpropkey, LargeStringProperty enpropcontent where doc.web='${app}' and doc.fullName=obj.name and obj.className='L10NCode.TranslationClass' and obj.id=prop.id.id and prop.id.name='name' and prop.value='${name}' and obj.id=proplang.id.id and proplang.id.name='language' and proplang.value='${language}' and propcontent.id.id=obj.id and propcontent.id.name='originaltext' and obj.id=propkey.id.id and propkey.id.name='key' and enobj.className='L10NCode.TranslationClass' and enobj.id=enprop.id.id and enprop.id.name='name' and enprop.value='${name}' and enobj.id=enproplang.id.id and enproplang.id.name='language' and enproplang.value='${dlang}' and enpropcontent.id.id=enobj.id and enpropcontent.id.name='originaltext' and enobj.id=enpropkey.id.id and enpropkey.id.name='key' and propkey.value=enpropkey.value and enpropcontent.value&lt;&gt;propcontent.value";
            result = count(sql);

            addToCache(countOutdatedCache, result, app, name, language, null, null, null, true);
        }

        return result;
    }

    /*
     * This will look for all translations that are non existent in the default language
     */
    public long countNonexistentTranslations(String app, String name, String language) throws XWikiException,
        QueryException
    {
        Long result = (Long) getFromCache(countNonexistentCache, app, name, language, null, null, null, true);
        if (result == null) {
            String dlang = getApplicationDefaultLanguage(app);
            String defaultsql =
                "select propkey.value from BaseObject as obj, StringProperty as prop, StringProperty as proplang, StringProperty as propkey where obj.className='L10NCode.TranslationClass' and obj.id=prop.id.id and prop.id.name='name' and prop.value='${name}' and obj.id=proplang.id.id and proplang.id.name='language' and proplang.value='${dlang}' and obj.id=propkey.id.id and propkey.id.name='key'";

            String sql =
                "select count(doc.id) from XWikiDocument as doc, BaseObject as obj, StringProperty as prop, StringProperty as proplang, StringProperty as propkey where doc.web='${app}' and doc.fullName=obj.name and obj.className='L10NCode.TranslationClass' and obj.id=prop.id.id and prop.id.name='name' and prop.value='${name}' and obj.id=proplang.id.id and proplang.id.name='language' and proplang.value='${language}' and obj.id=propkey.id.id and propkey.id.name='key' and propkey.value not in (${defaultsql})";
            result = count(sql);

            addToCache(countNonexistentCache, result, app, name, language, null, null, null, true);
        }

        return result;
    }

    // //////////////////////////////////////////////////////////////////////////////////
    // Latest translations
    // //////////////////////////////////////////////////////////////////////////////////

    public long countTranslations(String app, String name, String language, boolean withTranslator, String author)
        throws XWikiException, QueryException
    {
        String sqlWhere = "";

        if (StringUtils.isNotEmpty(author)) {
            sqlWhere = "doc.author = '${author}'";
        } else if (!withTranslator) {
            sqlWhere =
                "doc.author &lt;&gt; '${TRANSLATOR_FULL_NAME}' and doc.author &lt;&gt; 'XWiki.Admin' and doc.author &lt;&gt; 'XWiki.superadmin'";
        }

        if (StringUtils.isNotEmpty(app)) {
            if (sqlWhere.length() &gt; 0) {
                sqlWhere = " and ";
            }
            sqlWhere += "doc.space = '${app}'";
        }

        if (StringUtils.isNotEmpty(language)) {
            if (sqlWhere.length() &gt; 0) {
                sqlWhere = " and ";
            }
            sqlWhere += "translation.language = '${language}'";
        }

        if (StringUtils.isNotEmpty(name)) {
            if (sqlWhere.length() &gt; 0) {
                sqlWhere = " and ";
            }
            sqlWhere += "translation.name = '${name}'";
        }

        String sql =
            "select count(doc.id) from Document as doc, doc.object(L10NCode.TranslationClass) as translation where ${sqlWhere}";

        return countXWQL(sql, null);
    }

    public List getLatestTranslations(String app, int nb, int start, boolean withTranslator, String author)
        throws QueryException, UnsupportedEncodingException
    {
        String sqlWhere = "";

        if (StringUtils.isNotEmpty(author)) {
            sqlWhere = "doc.author = '${author}'";
        } else if (!withTranslator) {
            sqlWhere =
                "doc.author &lt;&gt; '${TRANSLATOR_FULL_NAME}' and doc.author &lt;&gt; 'XWiki.Admin' and doc.author &lt;&gt; 'XWiki.superadmin'";
        }

        if (StringUtils.isNotEmpty(app)) {
            if (sqlWhere.length() &gt; 0) {
                sqlWhere = " and ";
            }
            sqlWhere += "doc.space = '${app}'";
        }

        String sql =
            "select doc.space, doc.name, doc.fullName, doc.date, doc.author, translation.key, translation.language, translation.originaltext, translation.translatedtext from Document as doc, doc.object(L10NCode.TranslationClass) as translation where ${sqlWhere} order by doc.date desc";

        Query query = getQueryManager().createQuery(sql, Query.XWQL);

        query.setOffset(start);
        query.setLimit(nb);

        return getTranslationsFromQuery((List) query.execute());
    }

    public List&lt;Map&lt;String, String&gt;&gt; getTranslationsFromQuery(List&lt;Object[]&gt; queryResult)
        throws UnsupportedEncodingException
    {
        List&lt;Map&lt;String, String&gt;&gt; list = new ArrayList&lt;Map&lt;String, String&gt;&gt;();

        for (Object[] item : queryResult) {
            Map&lt;String, String&gt; row = new HashMap&lt;String, String&gt;();

            row.put("docSpace", (String) item[0]);
            row.put("application", (String) item[0]);
            row.put("docName", (String) item[1]);
            row.put("docFullName", (String) item[2]);
            row.put("date", xwiki.formatDate((Date) item[3]));
            row.put("author", (String) item[4]);
            row.put("key", (String) item[5]);
            row.put("language", (String) item[6]);

            String origtext = (String) item[7];
            if (origtext != null) {
                row.put("origtext", origtext.length() &gt; 250 ? origtext.substring(0, 250) + "..." : origtext);
            }

            String transtext = (String) item[8];
            if (transtext != null) {
                row.put("transtext", transtext.length() &gt; 250 ? transtext.substring(0, 250) + "..." : transtext);
            }

            StringBuilder keyUrl = new StringBuilder();

            keyUrl.append("/xwiki/bin/view/");
            keyUrl.append(URLEncoder.encode(row.get("docSpace"), "UTF-8"));
            keyUrl.append('/');
            keyUrl.append(URLEncoder.encode(row.get("docName"), "UTF-8"));

            // mostly for livetable
            row.put("key_url", keyUrl.toString());
            row.put("author_url", "/xwiki/bin/view/XWiki/" + URLEncoder.encode(row.get("author").substring(6), "UTF-8"));

            list.add(row);
        }

        return list;
    }

    // //////////////////////////////////////////////////////////////////////////////////
    // Latest translations with history (very expensive)
    // //////////////////////////////////////////////////////////////////////////////////

    /*
     * This will count the translations in a language
     */
    public long countTranslationsInHistory(String app, String name, String language) throws XWikiException,
        QueryException
    {
        return countTranslationsInHistory(app, name, language, true, null);
    }

    public long countTranslationsInHistory(String app, String name, String language, boolean withTranslator,
        String author) throws XWikiException, QueryException
    {
        String sqlFrom = "XWikiDocument as doc, BaseObject as obj";

        String sqlApp = "";
        if (app != null &amp;&amp; app.length() &gt; 0) {
            sqlApp = "and doc.space = '${app}'";
        }

        String sqlLanguage = "";
        if (language != null &amp;&amp; language.length() &gt; 0) {
            sqlFrom += ", StringProperty as proplang";
            sqlLanguage = "and obj.id=proplang.id.id and proplang.id.name='language' and proplang.value='${language}'";
        }

        String sqlAuthor = "";
        if (author != null &amp;&amp; author.length() &gt; 0) {
            sqlFrom += ", XWikiRCSNodeInfo as rcs";
            sqlAuthor = "and rcs.id.docId=doc.id and rcs.author = '${author}'";
        } else if (!withTranslator) {
            sqlFrom += ", XWikiRCSNodeInfo as rcs";
            sqlAuthor =
                "and rcs.id.docId=doc.id and rcs.author &lt;&gt; '${TRANSLATOR_FULL_NAME}' and rcs.author &lt;&gt; 'XWiki.Admin' and rcs.author &lt;&gt; 'XWiki.superadmin'";
        }

        String sqlName = "";
        if (name != null &amp;&amp; name.length() &gt; 0) {
            sqlFrom += ", StringProperty as prop";
            sqlName = "and obj.id=prop.id.id and prop.id.name='name' and prop.value='${name}'";
        }

        Long result = (Long) getFromCache(countCache, app, name, language, author, null, null, withTranslator);
        if (result == null) {
            String sql =
                "select count(*) from ${sqlFrom} where doc.fullName=obj.name and obj.className='L10NCode.TranslationClass' ${sqlName} ${sqlApp} ${sqlAuthor} ${sqlLanguage}";

            result = count(sql);
            addToCache(countCache, result, app, name, language, author, null, null, withTranslator);
        }

        return result;
    }

    public List countTranslationsByUserInHistory(String app, String name, String language, boolean withTranslator,
        int limit, int offset) throws QueryException
    {
        return countTranslationsByUserInHistory(app, name, language, withTranslator, limit, offset, null);
    }

    public List countTranslationsByUserInHistory(String app, String name, String language, boolean withTranslator,
        int limit, int offset, Integer year) throws QueryException
    {
        return countTranslationsByUserInHistory(app, name, language, withTranslator, limit, offset, year, null, null);
    }

    public List countTranslationsByUserInHistory(String app, String name, String language, boolean withTranslator,
        int limit, int offset, Integer year, Date lowerBound, Date upperBound) throws QueryException
    {
        List&lt;Object&gt; values = new ArrayList&lt;Object&gt;();

        String sqlFrom = "XWikiDocument as doc, BaseObject as obj, XWikiRCSNodeInfo as rcs";

        String sqlName = "";
        if (name != null &amp;&amp; name.length() &gt; 0) {
            sqlFrom += ", StringProperty as prop";
            sqlName = "and obj.id=prop.id.id and prop.id.name='name' and prop.value=?";
            values.add(name);
        }

        String sqlApp = "";
        if (app != null &amp;&amp; app.length() &gt; 0) {
            sqlApp = "and doc.space=?";
            values.add(app);
        }

        String sqlAuthor = "";
        if (!withTranslator) {
            sqlAuthor =
                "and rcs.author &lt;&gt; '${TRANSLATOR_FULL_NAME}' and rcs.author &lt;&gt; 'XWiki.Admin' and rcs.author &lt;&gt; 'XWiki.superadmin'";
        }

        String sqlLanguage = "";
        if (language != null &amp;&amp; language.length() &gt; 0) {
            sqlFrom += ", StringProperty as proplang";
            sqlLanguage = "and obj.id=proplang.id.id and proplang.id.name='language' and proplang.value=?";
            values.add(language);
        }

        String sqlYear = "";
        if (year != null) {
            sqlYear = "and year(rcs.date) = ?";
            values.add(year);
        }

        String sqlLowerDateBound = "";
        if (lowerBound != null) {
            sqlLowerDateBound = "and rcs.date &gt;= ?";
            values.add(lowerBound);
        }

        String sqlUpperDateBound = "";
        if (upperBound != null) {
            sqlUpperDateBound = "and rcs.date &lt; ?";
            values.add(upperBound);
        }

        List result =
            (List) getFromCache(countByUserCache, app, name, language, null, limit, offset, withTranslator, values);
        if (result == null) {
            String sql =
                "select count(distinct rcs.id) as contributions, rcs.author from ${sqlFrom} where doc.fullName=obj.name and obj.className='L10NCode.TranslationClass' and rcs.id.docId=doc.id ${sqlName} ${sqlApp} ${sqlAuthor} ${sqlLanguage} ${sqlYear} ${sqlLowerDateBound} ${sqlUpperDateBound} group by rcs.author order by 1 desc";

            Query query = getQueryManager().createQuery(sql, Query.HQL);
            if (values != null) {
                query.bindValues((List) values);
            }
            query.setOffset(offset);
            query.setLimit(limit);

            result = query.execute();

            addToCache(countByUserCache, result, app, name, language, null, limit, offset, withTranslator, values);
        }

        return result;
    }

    public List countTranslationsByLanguageInHistory(String app, String name, String language, boolean withTranslator,
        int limit, int offset, Integer year, Date lowerBound, Date upperBound) throws QueryException
    {
        List&lt;Object&gt; values = new ArrayList&lt;Object&gt;();

        String sqlFrom = "XWikiDocument as doc, BaseObject as obj, XWikiRCSNodeInfo as rcs, StringProperty as proplang";

        String sqlName = "";
        if (name != null &amp;&amp; name.length() &gt; 0) {
            sqlFrom += ", StringProperty as prop";
            sqlName = "and obj.id=prop.id.id and prop.id.name='name' and prop.value=?";
            values.add(name);
        }

        String sqlApp = "";
        if (app != null &amp;&amp; app.length() &gt; 0) {
            sqlApp = "and doc.space=?";
            values.add(app);
        }

        String sqlAuthor = "";
        if (!withTranslator) {
            sqlAuthor =
                "and rcs.author &lt;&gt; '${TRANSLATOR_FULL_NAME}' and rcs.author &lt;&gt; 'XWiki.Admin' and rcs.author &lt;&gt; 'XWiki.superadmin'";
        }

        String sqlLanguage = "";
        if (language != null &amp;&amp; language.length() &gt; 0) {
            sqlLanguage = " and proplang.value=?";
            values.add(language);
        }

        String sqlYear = "";
        if (year != null) {
            sqlYear = "and year(rcs.date) = ?";
            values.add(year);
        }

        String sqlLowerDateBound = "";
        if (lowerBound != null) {
            sqlLowerDateBound = "and rcs.date &gt;= ?";
            values.add(lowerBound);
        }

        String sqlUpperDateBound = "";
        if (upperBound != null) {
            sqlUpperDateBound = "and rcs.date &lt; ?";
            values.add(upperBound);
        }

        List result =
            (List) getFromCache(countByLanguageCache, app, name, language, null, limit, offset, withTranslator, values);
        if (result == null) {
            String sql =
                "select count(distinct rcs.id) as contributions, proplang.value from ${sqlFrom} where doc.fullName=obj.name and obj.className='L10NCode.TranslationClass' and rcs.id.docId=doc.id and obj.id=proplang.id.id and proplang.id.name='language' ${sqlName} ${sqlApp} ${sqlAuthor} ${sqlLanguage} ${sqlYear} ${sqlLowerDateBound} ${sqlUpperDateBound} group by proplang.value order by 1 desc";

            Query query = getQueryManager().createQuery(sql, Query.HQL);
            if (values != null) {
                query.bindValues((List) values);
            }
            query.setOffset(offset);
            query.setLimit(limit);

            result = query.execute();

            addToCache(countByLanguageCache, result, app, name, language, null, limit, offset, withTranslator, values);
        }

        return result;
    }

    public List&lt;Map&lt;String, Object&gt;&gt; getLatestTranslationsInHistory(String app, int nb, int start)
        throws XWikiException
    {
        return getLatestTranslationsInHistory(app, nb, start, true);
    }

    public List&lt;Map&lt;String, Object&gt;&gt; getLatestTranslationsInHistory(String app, int nb, int start,
        boolean withTranslator) throws XWikiException
    {
        return getLatestTranslationsInHistory(app, nb, start, withTranslator, null);
    }

    public List&lt;Map&lt;String, Object&gt;&gt; getLatestTranslationsInHistory(String app, int nb, int start, String author)
        throws XWikiException
    {
        return getLatestTranslationsInHistory(app, nb, start, true, author);
    }

    public List&lt;Map&lt;String, Object&gt;&gt; getLatestTranslationsInHistory(String app, int nb, int start,
        boolean withTranslator, String author) throws XWikiException
    {
        List&lt;Map&lt;String, Object&gt;&gt; list = new ArrayList&lt;Map&lt;String, Object&gt;&gt;();

        String sqlApp = "";
        if (app != null &amp;&amp; app.length() &gt; 0) {
            sqlApp = "and doc.space = '${app}'";
        }

        String sqlAuthor = "";
        if (author != null &amp;&amp; author.length() &gt; 0) {
            sqlApp = "and rcs.author = '${author}'";
        } else if (!withTranslator) {
            sqlAuthor =
                "and rcs.author &lt;&gt; '${TRANSLATOR_FULL_NAME}' and rcs.author &lt;&gt; 'XWiki.Admin' and rcs.author &lt;&gt; 'XWiki.superadmin'";
        }

        String sql =
            "select doc.fullName, rcs.date, rcs.author from XWikiRCSNodeInfo as rcs, XWikiDocument as doc, BaseObject as obj where rcs.id.docId=doc.id and doc.fullName=obj.name and obj.className='L10NCode.TranslationClass' ${sqlApp} ${sqlAuthor} order by rcs.date desc";

        List&lt;Object[]&gt; result =
            (List&lt;Object[]&gt;) getFromCache(lastTranslationsCache, app, null, null, author, nb, start, withTranslator);
        if (result == null) {
            result = this.privateXWiki.search(sql, nb, start, this.privateContext);
            addToCache(lastTranslationsCache, result, app, null, null, author, nb, start, withTranslator);
        }

        for (Object[] item : result) {
            Map&lt;String, Object&gt; row = new HashMap&lt;String, Object&gt;();

            String pagename = (String) item[0];
            Document itemdoc = xwiki.getDocument((String) pagename);

            row.put("pagename", pagename);
            row.put("itemdoc", itemdoc);
            row.put("date", xwiki.formatDate((Date) item[1]));
            row.put("author", item[2]);
            row.put("authordoc", xwiki.getDocument((String) item[2]));
            row.put("key", itemdoc.getValue(T_PROP_KEY));
            row.put("language", itemdoc.getValue(T_PROP_LANGUAGE));

            String origtext = (String) itemdoc.getValue(T_PROP_ORIGINALTEXT);
            if (origtext != null) {
                row.put("origtext", origtext.length() &gt; 250 ? origtext.substring(0, 250) + "..." : origtext);
            }

            String transtext = (String) itemdoc.getValue(T_PROP_TRANSLATEDTEXT);
            if (transtext != null) {
                transtext = transtext.length() &gt; 250 ? transtext.substring(0, 250) + "..." : transtext;
            }
            row.put("transtext", transtext);

            list.add(row);
        }

        return list;
    }

    // //////////////////////////////////////////////////////////////////////////////////
    // Refactoring
    // //////////////////////////////////////////////////////////////////////////////////

    /**
     * Move/rename a translation file and all it's associated translations.
     */
    public void moveTranslation(String sourceApp, String sourceTranslation, String targetApp, String targetTranslation)
        throws Exception
    {
        Document document = xwiki.getDocument(sourceTranslation);

        if (document.isNew()) {
            throw new Exception("Translation [" + sourceTranslation + "] does not exists");
        }

        // Move translations and default language
        Set&lt;String&gt; languages = new HashSet&lt;String&gt;(Arrays.asList(getApplicationLanguages(sourceApp)));
        languages.add(getApplicationDefaultLanguage(sourceApp));
        for (String language : languages) {
            Collection&lt;String&gt; keys = getTranslationKeys(sourceApp, sourceTranslation, language);

            for (String key : keys) {
                try {
                    moveTranslationKey(sourceApp, sourceTranslation, key, targetApp, targetTranslation, key, language);
                } catch (XWikiException e) {

                }
            }
        }

        // Move home page
        document.rename(targetTranslation);
    }

    public void moveTranslationKey(String sourceApp, String sourceTranslation, String sourceKey, String targetApp,
        String targetTranslation, String targetKey) throws Exception
    {
        Set&lt;String&gt; languages = new HashSet&lt;String&gt;(Arrays.asList(getApplicationLanguages(sourceApp)));
        languages.add(getApplicationDefaultLanguage(sourceApp));

        for (String language : languages) {
            moveTranslationKey(sourceApp, sourceTranslation, sourceKey, targetApp, targetTranslation, targetKey,
                language);
        }
    }

    public void moveTranslationKey(String sourceApp, String sourceTranslation, String sourceKey, String targetApp,
        String targetTranslation, String targetKey, String language) throws Exception
    {
        DocumentReference currentUser = privateContext.getUserReference();
        try {
            // Make sure pages are created with a generic user
            privateContext.setUser(TRANSLATOR_FULL_NAME);

            String sourceDocumentName = sourceApp + '.' + getPageName(sourceTranslation, sourceKey, language);
            String targetDocumentName = targetApp + '.' + getPageName(targetTranslation, targetKey, language);

            // Make sure target is not teh source
            if (targetDocumentName == sourceDocumentName) {
                throw new Exception("Source and target must be different");
            }

            // Delete existing document
            Document targetDocument = xwiki.getDocument(targetDocumentName);
            if (!targetDocument.isNew()) {
                targetDocument.delete();
            }

            // Load source document
            Document sourceDocument = xwiki.getDocument(sourceDocumentName);

            // Rename
            sourceDocument.rename(targetDocumentName);

            // Fix properties
            targetDocument = xwiki.getDocument(targetDocumentName);
            if (!targetDocument.isNew()) {
                targetDocument.set(T_PROP_NAME, targetTranslation);
                targetDocument.set(T_PROP_KEY, targetKey);
                targetDocument.save("Update translation name after move", false);
            } else {
                throw new Exception("Failed to move [" + sourceDocument + "] to [" + targetDocumentName + "]");
            }
        } finally {
            privateContext.setUserReference(currentUser);
        }
    }

    public void moveTranslationKeys(String json) throws Exception
    {
      def slurper = new JsonSlurper()
      def result = slurper.parseText(json)
      
      for (def row : result) {
        def sourceTranslation = row.get("sourceTranslation");
        def sourceApp  = row.get("sourceApp");
        def sourceKey  = row.get("sourceKey");
        def targetTranslation = row.get("targetTranslation");
        def targetApp  = row.get("targetApp");
        def targetKey  = row.get("targetKey");
        moveTranslationKey(sourceApp, sourceTranslation, sourceKey, targetApp, targetTranslation, targetKey);
      }
    }

    public void copyTranslationKey(String sourceApp, String sourceTranslation, String sourceKey, String targetApp,
        String targetTranslation, String targetKey) throws Exception
    {
        Set&lt;String&gt; languages = new HashSet&lt;String&gt;(Arrays.asList(getApplicationLanguages(sourceApp)));
        languages.add(getApplicationDefaultLanguage(sourceApp));

        for (String language : languages) {
            copyTranslationKey(sourceApp, sourceTranslation, sourceKey, targetApp, targetTranslation, targetKey,
                language);
        }
    }

    public void copyTranslationKey(String sourceApp, String sourceTranslation, String sourceKey, String targetApp,
        String targetTranslation, String targetKey, String language) throws Exception
    {
        DocumentReference currentUser = privateContext.getUserReference();
        try {
            // Make sure pages are created with a generic user
            privateContext.setUser(TRANSLATOR_FULL_NAME);

            Document document =
                xwiki.getDocument(sourceApp + '.' + getPageName(sourceTranslation, sourceKey, language));

            if (document.isNew()) {
                throw new Exception("No translation could be found for app:" + sourceApp + ", name:"
                    + sourceTranslation + " and key:" + sourceKey + " (" + document + ")");
            }

            String targetDocumentName = targetApp + '.' + getPageName(targetTranslation, targetKey, language);

            if (xwiki.copyDocument(document.getFullName(), targetDocumentName, null, null, null, true, true)) {
                Document targetDocument = xwiki.getDocument(targetDocumentName);
                targetDocument.set(T_PROP_NAME, targetTranslation);
                targetDocument.set(T_PROP_KEY, targetKey);
                try {
                    targetDocument.save("Update translation name after copy", false);
                } catch (Exception e) {
                    // Some weird bug of copyDocument when the document already exist
                }
            } else {
                throw new Exception("Failed to copy [" + document + "] to [" + targetDocumentName + "]");
            }
        } finally {
            privateContext.setUserReference(currentUser);
        }
    }

    public void copyTranslationKeys(String json) throws Exception
    {
      def slurper = new JsonSlurper()
      def result = slurper.parseText(json)
      
      for (def row : result) {
        def sourceTranslation = row.get("sourceTranslation");
        def sourceApp  = row.get("sourceApp");
        def sourceKey  = row.get("sourceKey");
        def targetTranslation = row.get("targetTranslation");
        def targetApp  = row.get("targetApp");
        def targetKey  = row.get("targetKey");
        copyTranslationKey(sourceApp, sourceTranslation, sourceKey, targetApp, targetTranslation, targetKey);
      }
    }
}

/*
 * *#
 */
</content>
  <object>
    <name>L10NCode.L10NGroovy</name>
    <number>0</number>
    <className>XWiki.TagClass</className>
    <guid>b0aeb826-774e-48ba-8c2c-e512056e02e2</guid>
    <class>
      <name>XWiki.TagClass</name>
      <customClass/>
      <customMapping/>
      <defaultViewSheet/>
      <defaultEditSheet/>
      <defaultWeb/>
      <nameField/>
      <validationScript/>
      <tags>
        <cache>0</cache>
        <disabled>0</disabled>
        <displayType>input</displayType>
        <multiSelect>1</multiSelect>
        <name>tags</name>
        <number>1</number>
        <prettyName>Tags</prettyName>
        <relationalStorage>1</relationalStorage>
        <separator>|</separator>
        <separators>|,</separators>
        <size>30</size>
        <unmodifiable>0</unmodifiable>
        <values/>
        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>
      </tags>
    </class>
    <property>
      <tags/>
    </property>
  </object>
</xwikidoc>
